\documentclass{article}

\usepackage{amsmath}

\newcommand{\Prog}{p}
\newcommand{\Progy}{p'}
\newcommand{\Reg}{x}
\newcommand{\Word}{w}
\newcommand{\Val}{v}
\newcommand{\Valy}{v'}
\newcommand{\Stack}{t}
\newcommand{\Heap}{h}
\newcommand{\Undef}{\mathtt{undef}}
\newcommand{\CodeFrag}{CF}
\newcommand{\HeapMap}{H}
\newcommand{\HeapMapy}{H'}
\newcommand{\TaskMap}{T}
\newcommand{\TaskMapy}{T'}
\newcommand{\Task}{s}
\newcommand{\Tasky}{s'}
\newcommand{\TName}{t}
\newcommand{\TNamey}{t'}
\newcommand{\FName}{f}
\newcommand{\HName}{h}
\newcommand{\Env}{c}
\newcommand{\Envy}{c'}
\newcommand{\State}{S}
\newcommand{\Code}{L}
\newcommand{\Codey}{L'}
\newcommand{\Store}{\sigma}

\newcommand{\reduces}[1][]{\xrightarrow{{#1}}}
\newcommand{\Reduces}{\rightarrow}
\newcommand{\MReduces}[1][\TName]{\ _{#1}\reduces}
\newcommand{\IReduces}{\rightarrow_{\mathtt{i}}}
\newcommand{\FReduces}{\rightarrow_{\mathtt{f}}}
\newcommand{\Put}[2]{\{{#1}:={#2}\}}

\newcommand{\putGlobal}[3]{\mathrm{putGlobal}({#1},{#2},{#3})}
\newcommand{\addRead}[3]{\mathrm{addRead}({#1},{#2},{#3})}

\newcommand{\Inst}{i}
\newcommand{\CALL}[3][\Reg]{{#1}=\mathtt{call}\ {#2}({#3})}
\newcommand{\LOAD}[2][\Reg]{{#1}=\mathtt{load}\ {#2}}
\newcommand{\STORE}[2][\Val]{\mathtt{store}\ {#1}\ {#2}}
\newcommand{\MALLOC}[1][\Reg]{{#1} = \mathtt{malloc}}
\newcommand{\FUTURE}[3][\Reg]{{#1} = \mathtt{future}\ {#2}({#3})}
\newcommand{\FORCE}[2][\Val]{\mathtt{force}\ {#1}}
\newcommand{\RET}[1][\Val]{\mathtt{ret}\ {#1}}
\newcommand{\BR}[3][\Val]{\mathtt{br}\ {#1}\ {#2}\ {#3}}
\newcommand{\OP}[2][\Reg]{{#1}\ =\ {#2}}
\newcommand{\Nil}{\mathtt{nil}}
\newcommand{\Args}{A}
\newcommand{\Bind}[2][\FName]{\mathrm{bind}({#1},{#2})}
\newcommand{\Op}{o}
\newcommand{\Var}{x}
\newcommand{\Exp}{e}
\newcommand{\Deref}[1][\Val]{*{#1}}
\newcommand{\Nat}{i}
\newcommand{\Malloc}{\mathtt{malloc}}
\newcommand{\Future}[3]{\mathtt{future}\ {#1}\ {#2}.{#3}}
\newcommand{\Force}[1][\Val]{\mathtt{force}\ {#1}}
\newcommand{\If}[3][\Val]{\mathtt{if}\ {#1}\ {#2}\ {#3}}
\newcommand{\TStatus}{b}
\newcommand{\HeapVal}{u}
\newcommand{\Node}{n}
\newcommand{\Edges}{E}
\newcommand{\Access}{a}
\newcommand{\Edge}{e}
\newcommand{\Nodes}{l}
\newcommand{\AccessMap}{A}

\newcommand{\grmor}{|}
\newcommand{\Grmor}{\ \grmor\ }
\newcommand{\Grmeq}{::=}

\title{Language with futures}
\date{}

\begin{document}
\maketitle

Numbers:

$$
\Nat \Grmeq \dots \Grmor 0 \Grmor 1 \Grmor 2 \Grmor \dots
$$

Words, where $\TName$ are task names and $\HName$ are heap names:

$$
\Word \Grmeq \Nat \Grmor \TName \Grmor \HName
$$

Run-time values, where $\Var$ are variable names:

$$
\Val \Grmeq \Word \Grmor \Var
$$

Expressions:

$$
\begin{aligned}
\Exp    \Grmeq & \Val  \\
        \Grmor & \Deref \\
        \Grmor & \Malloc \\
        \Grmor & \Future {\vec \Val}  {\vec \Var} \Prog \\
        \Grmor & \Force 
\end{aligned}
$$

Instructions:

$$
\Inst   ::=\  \Var = \Exp \ |\ * \Val = \Val 
$$

Programs:

$$
\Prog ::= \Inst; \Prog \ |\ \If \Prog \Prog \ |\ \RET
$$

Local store:

$$
\sigma ::= \{\Var_1:\Word_1,\dots,\Var_n:\Word_n\}
$$

Task status (running or stopped):

$$
\TStatus \Grmeq (\sigma, \Prog) \Grmor \Word
$$

Task:

$$
\Task \Grmeq (\Nat,\TStatus)
$$

Task map:

$$
\TaskMap ::= \{\TName_1:\Task_1,\dots,\TName_n:\Task_n\}
$$

Heap values (words or undefined):

$$
\HeapVal \Grmeq \Word \Grmor ?
$$

Heap:

$$
\HeapMap ::= \{\HName_1\colon \HeapVal_1,\dots,\HName_n\colon \HeapVal_n\}
$$

Node (from the computation-graph):

$$
\Node \Grmeq (\TName,\Nat)
$$

Edge:

$$
\Edge \Grmeq (\Node,\Node)
$$

Set of edges:

$$
\Edges \Grmeq \{ \Edge_1,\dots,\Edge_n\}
$$

Set of nodes:

$$
\Nodes \Grmeq \{ \Node_1,\dots,\Node_n\}
$$

Read and write accesses:

$$
\Access \Grmeq (\Nodes,\Nodes)
$$

Access map (shadow memory):

$$
\AccessMap \Grmeq \{ \HName_1\colon \Access_1,\dots,\HName_n\colon\Access_n\}
$$

State:

$$
\State ::= (\HeapMap,\Edges,\AccessMap,\TaskMap)
$$

\newpage

\newcommand{\Local}[1][\State]{\vdash_{#1}}
\newcommand{\Time}[1][\State]{\vdash_{#1}}
\newcommand{\Program}[1][\State]{\vdash_{#1}}

\noindent
\textbf{Get store:}\quad\fbox{$\TName \Local \Store$}
$$
\frac{
  \TaskMap(\State)(\TName) \mapsto (\Nat,(\Store,\Prog))
}{
  \TName \Local \Store
}
$$

\noindent
\textbf{Current time:}\quad\fbox{$\TName \Time \Nat$}
$$
\frac{
  \TaskMap(\State)(\TName) \mapsto (\Nat,\TStatus)
}{
  \TName \Time \Nat
}
$$

\noindent
\textbf{Program:}\quad\fbox{$\TName \Program \Prog$}
$$
\frac{
  \TaskMap(\State)(\TName) \mapsto (\Nat,(\Store,\Prog))
}{
  \TName \Program \Prog
}
$$

\newcommand{\VReduces}[2][\State]{\ _{{#1},{#2}}\Reduces}

\noindent
\textbf{Reduces value:}\quad\fbox{$\Val \VReduces \TName \Word$}
  %
  $$
  \frac{
    \TName \Local \Store \qquad \Store(\Var) \mapsto \Word
  }{
    \Var \VReduces \TName \Word
  }
  \qquad
  \Word \VReduces \TName \Word
  $$
  %
  %
  \textbf{Reduces memory:}\quad \fbox{$(\State,\Exp) \MReduces (\State,\Val)$}
  $$
  \frac{
    \Val \VReduces \TName \HName
    \qquad
    \HeapMap(\State)(\HName) \mapsto \Word
    \qquad
    \TName \Time \Nat
  }{
    (\State,\Deref) \MReduces (\addRead {\HName} {(\TName,\Nat)} \State,\Word)
  }
  \qquad
  \frac{
    \HName \notin \HeapMap(\State)
  }{
    (\State,\Malloc) \MReduces (\putGlobal \HName ? \State,\HName)
  }
  $$

\end{document}
