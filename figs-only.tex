\documentclass{article}

\usepackage{amsmath}

\newcommand{\Prog}{p}
\newcommand{\Progy}{p'}
\newcommand{\Reg}{x}
\newcommand{\Word}{w}
\newcommand{\Val}{v}
\newcommand{\Valy}{v'}
\newcommand{\Stack}{t}
\newcommand{\Heap}{h}
\newcommand{\Undef}{\mathtt{undef}}
\newcommand{\CodeFrag}{CF}
\newcommand{\HeapMap}{H}
\newcommand{\HeapMapy}{H'}
\newcommand{\TaskMap}{T}
\newcommand{\TaskMapy}{T'}
\newcommand{\Task}{s}
\newcommand{\Tasky}{s'}
\newcommand{\TName}{t}
\newcommand{\TNamey}{t'}
\newcommand{\FName}{f}
\newcommand{\HName}{h}
\newcommand{\Env}{c}
\newcommand{\Envy}{c'}
\newcommand{\State}{S}
\newcommand{\Code}{L}
\newcommand{\Codey}{L'}
\newcommand{\Store}{\sigma}

\newcommand{\reduces}[1][]{\xrightarrow{{#1}}}
\newcommand{\Reduces}{\rightarrow}
\newcommand{\EReduces}[2][\TName]{\ _{#1}\reduces[#2]}
\newcommand{\IReduces}{\rightarrow_{\mathtt{i}}}
\newcommand{\FReduces}{\rightarrow_{\mathtt{f}}}
\newcommand{\Put}[2]{\{{#1}:={#2}\}}

\newcommand{\putGlobal}[3]{\mathrm{putGlobal}({#1},{#2},{#3})}
\newcommand{\spawn}[4]{\mathrm{spawn}({#1},{#2},{#3},{#4})}


\newcommand{\Inst}{i}
\newcommand{\Nil}{\mathtt{nil}}
\newcommand{\Args}{A}
\newcommand{\Op}{o}
\newcommand{\Var}{x}
\newcommand{\Exp}{e}
\newcommand{\Deref}[1][\Val]{*{#1}}
\newcommand{\Nat}{i}
\newcommand{\Malloc}{\mathtt{malloc}}
\newcommand{\Future}[3]{\mathtt{future}\ {#1}\ {#2}.{#3}}
\newcommand{\Force}[1][\Val]{\mathtt{force}\ {#1}}
\newcommand{\If}[3][\Val]{\mathtt{if}\ {#1}\ {#2}\ {#3}}
\newcommand{\Ret}[1][\Val]{\mathtt{ret}\ {#1}}
\newcommand{\TStatus}{b}
\newcommand{\HeapVal}{u}
\newcommand{\Node}{n}
\newcommand{\Edges}{E}
\newcommand{\Access}{a}
\newcommand{\Edge}{e}
\newcommand{\Nodes}{l}
\newcommand{\AccessMap}{A}

\newcommand{\Local}[1][\State]{\vdash_{#1}}
\newcommand{\Time}[1][\State]{\vdash_{#1}}
\newcommand{\Program}[1][\State]{\vdash_{#1}}
\newcommand{\VReduces}[2][\State]{\ _{{#1},{#2}}\Reduces}
\newcommand{\Stopped}[1][\State]{\vdash_{#1}}
\newcommand{\Bind}[2][\State]{\ _{{#1},{#2}}\vdash}


\newcommand{\grmor}{|}
\newcommand{\Grmor}{\ \grmor\ }
\newcommand{\Grmeq}{::=}

\newcommand{\WRITE}[2][\TName]{\mathtt{w}({#1},{#2})}
\newcommand{\READ}[2][\TName]{\mathtt{r}({#1},{#2})}
\newcommand{\FUTURE}[2][\TName]{\mathtt{fut}({#1},{#2})}
\newcommand{\FORCE}[2][\TName]{\mathtt{frc}({#1},{#2})}
\newcommand{\TAU}{\tau}

\title{Language with futures}
\date{}

\begin{document}
\maketitle

\section{Language}


Numbers:

$$
\Nat \Grmeq \dots \Grmor 0 \Grmor 1 \Grmor 2 \Grmor \dots
$$

Words, where $\TName$ are task names and $\HName$ are heap names:

$$
\Word \Grmeq \Nat \Grmor \TName \Grmor \HName
$$

Run-time values, where $\Var$ are variable names:

$$
\Val \Grmeq \Word \Grmor \Var
$$

Expressions:

$$
\begin{aligned}
\Exp    \Grmeq & \Val  \\
        \Grmor & \Deref \\
        \Grmor & \Malloc \\
        \Grmor & \Future {\vec \Val}  {\vec \Var} \Prog \\
        \Grmor & \Force 
\end{aligned}
$$

Instructions:

$$
\Inst   ::=\  \Var = \Exp \ |\ \Deref = \Val 
$$

Programs:

$$
\Prog \Grmeq \Inst; \Prog \Grmor \If \Prog \Prog \Grmor \Ret
$$

Operations:
$$
\Op \Grmeq \WRITE \HName \Grmor \READ \HName \Grmor \FUTURE \TName \Grmor \FORCE \TName \Grmor \TAU
$$

Local store:

$$
\sigma ::= \{\Var_1:\Word_1,\dots,\Var_n:\Word_n\}
$$

Task:

$$
\Task \Grmeq (\Store, \Prog)
$$

Task map:

$$
\TaskMap ::= \{\TName_1:\Task_1,\dots,\TName_n:\Task_n\}
$$

Heap values (words or undefined):

$$
\HeapVal \Grmeq \Word \Grmor ?
$$

Heap:

$$
\HeapMap ::= \{\HName_1\colon \HeapVal_1,\dots,\HName_n\colon \HeapVal_n\}
$$

State:

$$
\State ::= (\HeapMap,\TaskMap)
$$

\newpage

\noindent
\textbf{Get store:}\quad\fbox{$\TName \Local \Store$}
$$
\frac{
  \TaskMap(\State)(\TName) \mapsto (\Store,\Prog)
}{
  \TName \Local \Store
}
$$

\noindent
\textbf{Program:}\quad\fbox{$\TName \Program \Prog$}
$$
\frac{
  \TaskMap(\State)(\TName) \mapsto (\Store,\Prog)
}{
  \TName \Program \Prog
}
$$


\noindent
\textbf{Reduces value:}\quad\fbox{$\Val \VReduces \TName \Word$}
  %
  $$
  \frac{
    \TName \Local \Store \qquad \Store(\Var) \mapsto \Word
  }{
    \Var \VReduces \TName \Word
  }
  \qquad
  \Word \VReduces \TName \Word
  $$
  %
 
\noindent
\textbf{Stopped:}\quad\fbox{$\TName \Stopped \Word$}
  %
  $$
  \frac{
    \TName \Program \Ret
    \qquad
    \Val \VReduces \TName \Word
  }{
    \TName \Stopped \Word
  }
  $$

\noindent
\textbf{Bind:}\quad\fbox{$(\vec\Val,\vec\Var) \Bind \TName \Store$}
  %
  $$
  \frac{
    \forall i \in \{1,\dots,n\} \colon \Val_i \VReduces \TName \Word_i
  }{
    (\Val_1\cdots\Val_n, \Var_1\cdots\Var_n)  \Bind \TName \{\Var_1\colon \Word_1,\dots,\Var_n\colon\Word_n\}
  }
  $$
  %

\noindent
  \textbf{Reduces expressions:}\quad \fbox{$(\State,\Exp) \EReduces \Op (\State,\Val)$}
  \begin{gather*}
  \frac{
    \Val \VReduces \TName \HName
    \qquad
    \HeapMap(\State)(\HName) \mapsto \Word
  }{
    (\State,\Deref) \EReduces {\READ \HName} (\State,\Word)
  }
  \qquad
  \frac{
    \HName \notin \HeapMap(\State)
  }{
    (\State,\Malloc) \EReduces {\TAU} (\putGlobal \HName ? \State,\HName)
  }
  \\
  \frac{
    (\vec\Val,\vec\Var) \Bind \TName \Store
    \qquad
    \TName' \notin \TaskMap(\State)
  }{
    (\State,\Future {\vec\Val} {\vec\Var} \Prog) \EReduces {\FUTURE {\TName'}} (\spawn {\TName'} {\Store} {\Prog} \State,\TName')
  }
  \qquad
  \frac{
    \Val \VReduces \TName {\TName'}
    \qquad
    \TName' \Stopped \Word
  }{
    (\State,\Force) \EReduces {\FORCE {\TName'}} (\State,\Word)
  }
  \qquad
  \end{gather*}


\section{Race detection}

Node (from the computation-graph):

$$
\Node \Grmeq (\TName,\Nat)
$$

Edge:

$$
\Edge \Grmeq (\Node,\Node)
$$

Set of edges:

$$
\Edges \Grmeq \{ \Edge_1,\dots,\Edge_n\}
$$

Set of nodes:

$$
\Nodes \Grmeq \{ \Node_1,\dots,\Node_n\}
$$

Read and write accesses:

$$
\Access \Grmeq (\Nodes,\Nodes)
$$

Access map (shadow memory):

$$
\AccessMap \Grmeq \{ \HName_1\colon \Access_1,\dots,\HName_n\colon\Access_n\}
$$

\end{document}
