\documentclass{article}

\usepackage{amsmath}

\newcommand{\Prog}{p}
\newcommand{\Progy}{p'}
\newcommand{\Reg}{x}
\newcommand{\Word}{w}
\newcommand{\Val}{v}
\newcommand{\Valy}{v'}
\newcommand{\Stack}{t}
\newcommand{\Heap}{h}
\newcommand{\Undef}{\mathtt{undef}}
\newcommand{\CodeFrag}{CF}
\newcommand{\HeapMap}{H}
\newcommand{\HeapMapy}{H'}
\newcommand{\TaskMap}{T}
\newcommand{\TaskMapy}{T'}
\newcommand{\Task}{s}
\newcommand{\Tasky}{s'}
\newcommand{\TName}{t}
\newcommand{\TNamey}{t'}
\newcommand{\FName}{f}
\newcommand{\HName}{h}
\newcommand{\Env}{c}
\newcommand{\Envy}{c'}
\newcommand{\State}{S}
\newcommand{\Code}{L}
\newcommand{\Codey}{L'}
\newcommand{\Local}{\sigma}

\newcommand{\reduces}[1][]{\xrightarrow{{#1}}}
\newcommand{\Reduces}{\rightarrow}
\newcommand{\EReduces}[2][\TName]{\reduces[{\OP[{#1}]{#2}}]}
\newcommand{\IReduces}[2][\TName]{\reduces[{\OP[{#1}]{#2}}]}
\newcommand{\PReduces}[2][\TName]{\reduces[{\OP[{#1}]{#2}}]}
\newcommand{\SReduces}[1]{\reduces[#1]}
\newcommand{\Put}[2]{\{{#1}:={#2}\}}

\newcommand{\putGlobal}[3]{\mathrm{putGlobal}({#1},{#2},{#3})}
\newcommand{\putLocal}[4]{\mathrm{putLocal}({#1},{#2},{#3},{#4})}
\newcommand{\spawn}[4]{\mathrm{spawn}({#1},{#2},{#3},{#4})}
\newcommand{\EEval}[2]{\mathrm{eval}{({#1},{#2})}}
\newcommand{\setProg}[3]{\mathrm{setProg}{({#1},{#2},{#3})}}

\newcommand{\Inst}{i}
\newcommand{\Nil}{\mathtt{nil}}
\newcommand{\Args}{A}
\newcommand{\Op}{o}
\newcommand{\Var}{x}
\newcommand{\Exp}{e}
\newcommand{\Deref}[1][\Val]{*{#1}}
\newcommand{\Store}[1][\Val]{\Deref[{#1}] = }
\newcommand{\Nat}{z}
\newcommand{\Naty}{z'}
\newcommand{\Malloc}{\mathtt{malloc}}
\newcommand{\Future}[3]{\mathtt{future}\ {#1}\ {#2}.{#3}}
\newcommand{\Force}[1][\Val]{\mathtt{force}\ {#1}}
\newcommand{\If}[3][\Val]{\mathtt{if}\ {#1}\ {#2}\ {#3}}
\newcommand{\Ret}[1][\Val]{\mathtt{ret}\ {#1}}
\newcommand{\TStatus}{b}
\newcommand{\HeapVal}{u}
\newcommand{\Node}{n}
\newcommand{\Edges}{E}
\newcommand{\Access}{a}
\newcommand{\Edge}{e}
\newcommand{\Nodes}{l}
\newcommand{\AccessMap}{A}
\newcommand{\Time}{N}

\newcommand{\GetLocal}[1][\TName]{|_{\mathtt{local}({#1})\ }}
\newcommand{\Program}[1][\TName]{|_{\mathtt{prog}({#1})\ }}
\newcommand{\VReduces}[2][\State]{\ _{{#1},{#2}}\Reduces}
\newcommand{\Stopped}[1][\TName]{|_{\mathtt{stop}({#1})}\ }
\newcommand{\Bind}[2][\State]{\ _{{#1},{#2}}\Reduces}

\newcommand{\grmor}{|}
\newcommand{\Grmor}{\ \grmor\ }
\newcommand{\Grmeq}{::=}

\newcommand{\OP}[2][\TName]{{#1}:{#2}}

\newcommand{\WRITE}[1]{\mathtt{write}\ {#1}}
\newcommand{\READ}[1]{\mathtt{read}\ {#1}}
\newcommand{\FUTURE}[1]{\mathtt{future}\ {#1}}
\newcommand{\FORCE}[1]{\mathtt{force}\ {#1}}
\newcommand{\TAU}{\tau}

\title{Language with futures}
\date{}

\begin{document}
\maketitle

\section{Language}


Numbers:

$$
\Nat \Grmeq \dots \Grmor 0 \Grmor 1 \Grmor 2 \Grmor \dots
$$

Words, where $\TName$ are task names and $\HName$ are heap names:

$$
\Word \Grmeq \Nat \Grmor \TName \Grmor \HName
$$

Run-time values, where $\Var$ are variable names:

$$
\Val \Grmeq \Word \Grmor \Var
$$

Expressions:

$$
\begin{aligned}
\Exp    \Grmeq & \Val  \\
        \Grmor & \Deref \\
        \Grmor & \Malloc \\
        \Grmor & \Future {\vec \Val}  {\vec \Var} \Prog \\
        \Grmor & \Force 
\end{aligned}
$$

Instructions:

$$
\Inst \Grmeq \Var = \Exp \Grmor \Store \Val 
$$

Programs:

$$
\Prog \Grmeq \Inst; \Prog \Grmor \If \Prog \Prog \Grmor \Ret
$$

\section{Abstract machine}

Operations:
$$
\Op \Grmeq \READ \HName \Grmor \WRITE \HName \Grmor  \FUTURE \TName \Grmor \FORCE \TName \Grmor \TAU
$$

Local store:

$$
\sigma ::= \{\Var_1:\Word_1,\dots,\Var_n:\Word_n\}
$$

Task:

$$
\Task \Grmeq (\Local, \Prog)
$$

Task map:

$$
\TaskMap ::= \{\TName_1:\Task_1,\dots,\TName_n:\Task_n\}
$$

Heap values (words or undefined):

$$
\HeapVal \Grmeq \Word \Grmor ?
$$

Heap:

$$
\HeapMap ::= \{\HName_1\colon \HeapVal_1,\dots,\HName_n\colon \HeapVal_n\}
$$

State:

$$
\State ::= (\HeapMap,\TaskMap)
$$

\noindent
\textbf{Task memory:}\quad\fbox{$\State \GetLocal \Local$}
$$
\frac{
  \TaskMap(\State)(\TName) \mapsto (\Local,\Prog)
}{
  \State \GetLocal \Local
}
$$

\noindent
\textbf{Program:}\quad\fbox{$\State \Program \Prog$}
$$
\frac{
  \TaskMap(\State)(\TName) \mapsto (\Local,\Prog)
}{
  \TName \Program \Prog
}
$$


\noindent
\textbf{Reduces value:}\quad\fbox{$\Val \VReduces \TName \Word$}
  %
  $$
  \frac{
    \TName \GetLocal \Local \qquad \Local(\Var) \mapsto \Word
  }{
    \Var \VReduces \TName \Word
  }
  \qquad
  \Word \VReduces \TName \Word
  $$
  %
 
\noindent
\textbf{Stopped:}\quad\fbox{$\State \Stopped \Word$}
  %
  $$
  \frac{
    \State \Program \Ret
    \qquad
    \Val \VReduces \TName \Word
  }{
    \State \Stopped \Word
  }
  $$

\noindent
\textbf{Bind:}\quad\fbox{$(\vec\Val,\vec\Var) \Bind \TName \Local$}
  %
  $$
  \frac{
    \forall i \in \{1,\dots,n\} \colon \Val_i \VReduces \TName \Word_i
  }{
    (\Val_1\cdots\Val_n, \Var_1\cdots\Var_n)  \Bind \TName \{\Var_1\colon \Word_1,\dots,\Var_n\colon\Word_n\}
  }
  $$
  %

  \noindent
  \textbf{Expression:}\quad\fbox{$\Inst \vdash \Exp$}
  %
  $$
  \Store \Exp \vdash \Exp
  \qquad
  \Var = \Exp \vdash \Exp
  $$
  %

\noindent
  \textbf{Reduces expressions:}\quad \fbox{$(\State,\Exp) \EReduces \Op  (\State,\Val)$}
  \begin{gather*}
  \frac{
    \Val \VReduces \TName \HName
    \qquad
    \HeapMap(\State)(\HName) \mapsto \Word
  }{
    (\State,\Deref) \EReduces {\READ \HName} (\State,\Word)
  }
  \qquad
  \frac{
    \HName \notin \HeapMap(\State)
  }{
    (\State,\Malloc) \EReduces {\TAU} (\putGlobal \HName ? \State,\HName)
  }
  \\
  \frac{
    (\vec\Val,\vec\Var) \Bind \TName \Local
    \qquad
    \TName' \notin \TaskMap(\State)
  }{
    (\State,\Future {\vec\Val} {\vec\Var} \Prog) \EReduces {\FUTURE {\TName'}} (\spawn {\TName'} {\Local} {\Prog} \State,\TName')
  }
  \qquad
  \frac{
    \Val \VReduces \TName {\TName'}
    \qquad
    \TName' \Stopped \Word
  }{
    (\State,\Force) \EReduces {\FORCE {\TName'}} (\State,\Word)
  }
  \end{gather*}


  \noindent
  \textbf{Reduces instructions:}\quad \fbox{$(\State,\Inst) \IReduces \Op \State$}
  \begin{gather*}
  \frac{
    \Val \VReduces \TName \HName
    \qquad
    \Valy \VReduces \TName \Word
  }{
    (\State,\Store \Valy) \EReduces {\WRITE {\HName}} {\putGlobal {\HName} {\Word} \State}
  }
  \qquad
  \frac{
    \Val \VReduces \TName \Word
  }{
    (\State,\Var = \Val) \EReduces {\TAU} {\putLocal \TName \Var \Word \State}
  }
  \end{gather*}

  \noindent
  \textbf{Reduces programs:}\quad \fbox{$(\State,\Prog) \PReduces \Op (\State,\Prog)$}
  \begin{gather*}
    \frac{
      \Inst \vdash \Exp
      \qquad
      (\State,\Exp) \EReduces \Op (\State',\Word)
    }{
      (\State,\Inst;\Prog) \PReduces \Op (\State',\EEval \Inst \Word;\Prog)
    }
    \qquad
    \frac{
      (\State,\Inst) \IReduces \Op \State'
    }{
      (\State,\Inst;\Prog) \PReduces \Op (\State',\Prog)
    }
    \\
    \frac{
    \Val \VReduces \TName 0
    }{
      (\State,\If {\Prog} {\Prog'}) \PReduces \TAU (\State,\Prog')
    }
    \qquad
    \frac{
    \Val \VReduces \TName \Nat
    \qquad
    \Nat \neq 0
    }{
      (\State,\If {\Prog} {\Prog'}) \PReduces \TAU (\State,\Prog)
    }
  \end{gather*}  

  \noindent
  \textbf{Reduces states:}\quad \fbox{$\State \SReduces \Op \State$}
  \begin{gather*}
    \frac{
      (\State,\Prog) \PReduces \Op (\State',\Prog')
    }{
      \State \SReduces \Op \setProg \TName {\Prog'} {\State'}
    }
  \end{gather*}

\section{Race detection}

Node (from the computation-graph):

$$
\Node \Grmeq (\TName,\Nat)
$$

Edge:

$$
\Edge \Grmeq (\Node,\Node)
$$

Set of edges:

$$
\Edges \Grmeq \{ \Edge_1,\dots,\Edge_n\}
$$

Set of nodes:

$$
\Nodes \Grmeq \{ \Node_1,\dots,\Node_n\}
$$

Time:
$$
\Time \Grmeq \{ \HName_1 \colon \Nat_1, \dots, \TName_n\colon \Nat_n\}
$$



Read and write accesses:

$$
\Access \Grmeq (\Nodes,\Nodes)
$$

Access map (shadow memory):

$$
\AccessMap \Grmeq \{ \HName_1\colon \Access_1,\dots,\HName_n\colon\Access_n\}
$$

\begin{gather*}  
\frac{
  \Time(\TName) \mapsto \Nat
  \qquad
}{
  (\Time, \Edges)
  \reduces[{\OP{\FUTURE \TNamey}}] 
  (\Time, \TName \colon \Nat + 1, \TNamey \colon 0, \Edges \cup \{((\TName,\Nat),(\TNamey,0))\})
}
\\
\frac{
  \Time(\TName) \mapsto \Nat
  \qquad
  \Time(\TNamey) \mapsto \Naty
}{
  (\Time, \Edges)
  \reduces[{\OP{\FORCE \TNamey}}]
  (\Time, \TName \colon \Nat + 1, \Edges \cup \{((\TName,\Nat),(\TNamey,\Naty))\}
}
\\
\frac{
  \forall \TNamey, \Op \neq \FORCE \TNamey
  \qquad
  \forall \TNamey, \Op \neq \FUTURE \TNamey
}{
  (\Time, \Edges) \reduces[{\OP{\Op}}] \Edges
}
\end{gather*}

\begin{gather*}
\frac{
  \Time(\TName) \mapsto \Nat
  \qquad
  \AccessMap(\HName) \mapsto (\Nodes_r,\Nodes_w)
}{
  (\Time, \AccessMap) \reduces[{\OP{\WRITE \HName}}] \AccessMap, \HName \colon (\Nodes_r,\Nodes_w \cup \{(\TName,\Nat)\})
}
\\
\frac{
  \Time(\TName) \mapsto \Nat
  \qquad
  \AccessMap(\HName) \mapsto (\Nodes_r,\Nodes_w)
}{
  (\Time, \AccessMap) \reduces[{\OP{\READ \HName}}] \AccessMap, \HName \colon (\Nodes_r\cup \{(\TName,\Nat)\},\Nodes_w )
}
\\
\frac{
  \forall \HName, \Op \neq \READ \HName
  \qquad
  \forall \HName, \Op \neq \WRITE \HName
}{
  (\Time, \AccessMap) \reduces[{\OP{\Op}}] \AccessMap
}
\\
\frac{
  \State \reduces[{\OP{\Op}}] \State'
  \qquad
  \Time \reduces[{\OP{\Op}}] \Time'
  \qquad
  (\Time, \Edges) \reduces[{\OP{\Op}}] \Edges
  \qquad
  (\Time, \AccessMap) \reduces[{\OP{\Op}}] \AccessMap
}{
  (\State,\Time,\Edges,\AccessMap)
  \reduces
  (\State',\Time',\Edges',\AccessMap')
}
\end{gather*}
\end{document}
