\documentclass{article}

\usepackage{amsmath}

\newcommand{\Prog}{p}
\newcommand{\Progy}{p'}
\newcommand{\Reg}{x}
\newcommand{\Word}{w}
\newcommand{\Val}{v}
\newcommand{\Valy}{v'}
\newcommand{\Stack}{t}
\newcommand{\Heap}{h}
\newcommand{\Undef}{\mathtt{undef}}
\newcommand{\CodeFrag}{CF}
\newcommand{\HeapMap}{H}
\newcommand{\HeapMapy}{H'}
\newcommand{\TaskMap}{T}
\newcommand{\TaskMapy}{T'}
\newcommand{\Task}{s}
\newcommand{\Tasky}{s'}
\newcommand{\TName}{t}
\newcommand{\TNamey}{t'}
\newcommand{\FName}{f}
\newcommand{\HName}{h}
\newcommand{\Env}{c}
\newcommand{\Envy}{c'}
\newcommand{\State}{S}
\newcommand{\Code}{L}
\newcommand{\Codey}{L'}
\newcommand{\Store}{\sigma}

\newcommand{\IReduces}{\rightarrow_{\mathtt{i}}}
\newcommand{\MReduces}{\rightarrow_{\mathtt{m}}}
\newcommand{\FReduces}{\rightarrow_{\mathtt{f}}}
\newcommand{\Reduces}{\rightarrow}
\newcommand{\Put}[2]{\{{#1}:={#2}\}}

\newcommand{\Inst}{i}
\newcommand{\CALL}[3][\Reg]{{#1}=\mathtt{call}\ {#2}({#3})}
\newcommand{\LOAD}[2][\Reg]{{#1}=\mathtt{load}\ {#2}}
\newcommand{\STORE}[2][\Val]{\mathtt{store}\ {#1}\ {#2}}
\newcommand{\MALLOC}[1][\Reg]{{#1} = \mathtt{malloc}}
\newcommand{\FUTURE}[3][\Reg]{{#1} = \mathtt{future}\ {#2}({#3})}
\newcommand{\FORCE}[2][\Val]{\mathtt{force}\ {#1}}
\newcommand{\RET}[1][\Val]{\mathtt{ret}\ {#1}}
\newcommand{\BR}[3][\Val]{\mathtt{br}\ {#1}\ {#2}\ {#3}}
\newcommand{\OP}[2][\Reg]{{#1}\ =\ {#2}}
\newcommand{\Nil}{\mathtt{nil}}
\newcommand{\Args}{A}
\newcommand{\Bind}[2][\FName]{\mathrm{bind}({#1},{#2})}
\newcommand{\Op}{o}
\newcommand{\Var}{x}
\newcommand{\Exp}{e}
\newcommand{\Deref}[1][\Var]{*{#1}}
\newcommand{\Nat}{i}
\newcommand{\Malloc}{\mathtt{malloc}}
\newcommand{\Future}[3]{\mathtt{future}\ {#1}\ {#2}.{#3}}
\newcommand{\Force}[1][\Val]{\mathtt{force}\ {#1}}
\newcommand{\If}[3][\Val]{\mathtt{if}\ {#1}\ {#2}\ {#3}}
\newcommand{\TStatus}{b}
\newcommand{\HeapVal}{u}
\newcommand{\Node}{n}
\newcommand{\Edges}{E}
\newcommand{\Access}{a}
\newcommand{\Edge}{e}
\newcommand{\Nodes}{l}
\newcommand{\AccessMap}{A}

\newcommand{\grmor}{|}
\newcommand{\Grmor}{\ \grmor\ }
\newcommand{\Grmeq}{::=}

\title{Language with futures}
\date{}

\begin{document}
\maketitle

Numbers:

$$
\Nat \Grmeq \dots \Grmor 0 \Grmor 1 \Grmor 2 \Grmor \dots
$$

Words, where $\TName$ are task names and $\HName$ are heap names:

$$
\Word \Grmeq \Nat \Grmor \TName \Grmor \HName
$$

Run-time values, where $\Var$ are variable names:

$$
\Val \Grmeq \Word \Grmor \Var
$$

Expressions:

$$
\begin{aligned}
\Exp    \Grmeq & \Val  \\
        \Grmor & \Deref \\
        \Grmor & \Malloc \\
        \Grmor & \Future {\vec \Val}  {\vec \Var} \Prog \\
        \Grmor & \Force 
\end{aligned}
$$

Instructions:

$$
\Inst   ::=\  \Var = \Exp \ |\ * \Val = \Val 
$$

Programs:

$$
\Prog ::= \Inst; \Prog \ |\ \If \Prog \Prog \ |\ \RET
$$

Local store:

$$
\sigma ::= \{\Var_1:\Word_1,\dots,\Var_n:\Word_n\}
$$

Task status (running or stopped):

$$
\TStatus \Grmeq (\sigma, \Prog) \Grmor \Word
$$

Task:

$$
\Task \Grmeq (\Nat,\TStatus)
$$

Task map:

$$
\TaskMap ::= \{\TName_1:\Task_1,\dots,\TName_n:\Task_n\}
$$

Heap values (words or undefined):

$$
\HeapVal \Grmeq \Word \Grmor ?
$$

Heap:

$$
\HeapMap ::= \{\HName_1\colon \HeapVal_1,\dots,\HName_n\colon \HeapVal_n\}
$$

Node (from the computation-graph):

$$
\Node \Grmeq (\TName,\Nat)
$$

Edge:

$$
\Edge \Grmeq (\Node,\Node)
$$

Set of edges:

$$
\Edges \Grmeq \{ \Edge_1,\dots,\Edge_n\}
$$

Set of nodes:

$$
\Nodes \Grmeq \{ \Node_1,\dots,\Node_n\}
$$

Read and write accesses:

$$
\Access \Grmeq (\Nodes,\Nodes)
$$

Access map (shadow memory):

$$
\AccessMap \Grmeq \{ \HName_1\colon \Access_1,\dots,\HName_n\colon\Access_n\}
$$

State:

$$
\State ::= (\HeapMap,\Edges,\AccessMap,\TaskMap)
$$

\newpage

\noindent
\textbf{Rules for load:}\quad\fbox{$\Store(\Val)\mapsto\Word$}
  %
  $$
  \frac{
    \Store(\Reg) = \Word
  }{
    \Store(\Reg) \mapsto \Word
  }
  \qquad
  \frac{
  }{
    \Store(\Word) \mapsto \Word
  }
  $$
  %
  \textbf{Call-frame load:}\quad\fbox{$\Store(\Val(\vec\Val)) \mapsto \Env$}
  $$
  \frac{
    \Store(\Val) \mapsto \FName
    \qquad
    \CodeFrag(\FName) = \Prog
    \qquad
    \Args(\FName) = \Reg_1, \dots,\Reg_n
    \qquad
    \forall i \in \{1,\dots,n\} : \Store(\Val_i) \mapsto \Word_i
  }{
    \Store, \Val(\Val_1,\dots,\Val_n)  \mapsto (\{ \Reg_1\colon \Word_1, \dots, \Reg_n \colon \Word_n \},\Prog)
  }
  $$
  %
   %
   \textbf{Rules for tasks (internal state):}\quad\fbox{$\Task\IReduces \Task$ }
  $$
  \frac{
    \Store( \Val (\vec\Val)) \mapsto \Env
  }{
    (\Store,\CALL \Val {\vec \Val};;\Prog)::\Stack
    \IReduces
    \Env::(\Store, \CALL \Val { \vec \Val};;\Prog)::\Stack
  }
   $$
   $$
   \frac{
     \Store(\Val) \mapsto \Word
     \qquad
     \Reg \notin \Store'
   }{
     (\Store,\RET)::(\Store', \CALL \_ \_;;p)::\Stack
     \IReduces
     (\Store'\Put \Reg \Word, \Prog)::\Stack
   }
   $$
   %
   \textbf{Rules for memory:}\quad\fbox{$(\HeapMap,\Env)\MReduces(\HeapMap,\Env)$}
   $$
   \frac{
     \Heap \notin \HeapMap
     \qquad
     \Reg \notin \Store
   }{
     (\HeapMap, (\Store,\MALLOC;; \Prog)) \MReduces (M\Put{\Heap}{\Undef}, (\Store\Put{\Reg}{\Heap}, \Prog))
   }
   $$
   $$
   \frac{
     \Store(\Val) \mapsto \Word
     \qquad
     \Store(\Valy) \mapsto \HName
     \qquad
     \Heap \in \HeapMap
   }{
     (\HeapMap, (\Store,\STORE \Valy;; p)) \MReduces (M\Put\Heap\Word, (\Store, \Prog))
   }
   $$
   $$
   \frac{
     \Store(\Val) \mapsto \Heap
     \qquad
     \HeapMap(\Heap) = \Word
     \qquad
     \Reg \notin \Store
   }{
     (\HeapMap, (\Store,\LOAD \Val;;\Prog)) \MReduces (\HeapMap, (\Store\Put\Reg\Word, \Prog))
   }
   $$
   %
   \textbf{Rules for futures:}\quad\fbox{$\TaskMap\FReduces\TaskMap$}
   $$
   \frac{
     \TaskMap(\TName) = (\Store,\FUTURE \Val {\vec \Val};; \Prog)::\Stack
     \qquad
     \Store(\Val (\vec\Val)) \mapsto \Env
     \qquad
     \TNamey \notin \TaskMap
     \qquad
     \Reg \notin \Store
   }{
     \TaskMap
     \FReduces
     \TaskMap
     \Put{\TName}{(\Store\Put{\Reg}{\TNamey},\Prog)::\Stack}
     \Put\TNamey{\Env::\Nil}
   }
   $$
   $$
   \frac{
     \TaskMap(\TName) = (\Store,\FORCE;; \Prog)::\Stack
     \qquad
     \Store(\Val) \mapsto {\TNamey}
     \qquad
     \TaskMap(\TNamey) = (\Store', \RET[\Valy])
     \qquad
     \Store'(v') \mapsto \Word
     \qquad
     \Reg \notin \Store
   }{
     \TaskMap
     \FReduces
     \TaskMap\Put\TName{(\Store\Put{\Reg}{\Word},\Prog)::\Stack}
   }
   $$
   \textbf{Rules for states:}\quad\fbox{$\State\Reduces\State$}
   %
   $$
   \frac{
     \TaskMap(\TName) = \Task
     \qquad
     \Task \IReduces \Tasky
   }{
     (\HeapMap,\TaskMap) \Reduces (\HeapMap, \TaskMap\Put\Heap{\Tasky})
   }
   \qquad
   \frac{
     \TaskMap(\TName) = \Env::\Stack
     \qquad
     (\HeapMap,\Env) \MReduces (\HeapMapy, \Envy)
   }{
     (\HeapMap,\TaskMap) \Reduces (\HeapMapy, \TaskMap\Put\TName{\Envy::\Task})
   }
   \qquad
   \frac{
     \TaskMap \FReduces \TaskMapy
   }{
     (\HeapMap,\TaskMap) \Reduces (\HeapMap, \TaskMapy)
   }
   $$

\newpage

Ill-formed state: Because $\TName_1$ does not consume

$$
\begin{aligned}
\FName_1 : & \LOAD y; \RET [0]\\
\FName_2 : & \RET [0] \\
y : & \TName_0 \\
\TName_0: & (\emptyset, \RET[0]) \\
\TName_1: & (\emptyset,\BR[0] {\FName_1}{\FName_2}) \\
\TName_2: & (\emptyset,\STORE[\TName_1] y)
\end{aligned}
$$

\end{document}
